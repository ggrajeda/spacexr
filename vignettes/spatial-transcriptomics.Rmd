---
title: "Applying RCTD to Spatial Transcriptomics Data"
author: "Dylan Cable"
date: "March 17th, 2021"
output:  
  rmarkdown::html_vignette:
vignette: >
  %\VignetteIndexEntry{spatial-transcriptomics}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  out.width = "100%"
)
```

## Introduction

Robust Cell Type Decomposition, or RCTD, is a statistical method for learning cell types from spatial transcriptomics data. In this vignette, we will use a simulated dataset to demonstrate the RCTD workflow.

## Setup

```{r setup, cache = FALSE}
library(ggplot2)
library(spacexr)
```

## Data Preprocessing

Let's begin by loading in the appropriate data.

### Reference

In order to run RCTD, the first step is to process the reference dataset. We will be using simulated data, but in practice, this reference could be an annotated dataset from single-nucleus RNA sequencing (snRNA-seq), single-cell RNA sequencing (scRNA-seq), or cell type-specific bulk RNA sequencing.

The reference is created using the RCTD `Reference` constructor function, which has 3 parameters:

1. `counts`: A matrix (or `dgCmatrix`) representing Digital Gene Expression (DGE). Row names should be genes and column names should represent barcodes/cell names. Counts should be untransformed count-level data.

2. `cell_types`: A named (by cell barcode) factor of cell type for each cell. The "levels" of the factor would be the possible cell type identities.

3. `nUMI`: Optional, a named (by cell barcode) list of total counts or UMIs appearing at each pixel. If not provided, `nUMI` will be assumed to be the total counts appearing on each pixel.

Here, we load counts and cell type annotations from the `rctd_simulation` object. In real-world datasets, the reference information may be distributed across several files or R objects.

```{r scRNA}
# Load simulated data.
data("rctd_simulation")

# Create Reference object.
reference <- Reference(
  rctd_simulation$reference_counts,
  rctd_simulation$reference_cell_types
)

# Examine reference. (optional)
print(dim(reference@counts))  # Digital Gene Expression matrix dimensions
table(reference@cell_types)   # Number of occurrences for each cell type
```
For this vignette, we have a reference dataset of 750 genes for 75 cells. We find that there are three cell types (`ct1`, `ct2`, and `ct3`), each appearing 25 times in the reference.

### Spatial Transcriptomics Data
Next, we will load the spatial transcriptomics data into a `SpatialRNA` object. Similar to the reference, we will pass our simulated data into the RCTD `SpatialRNA` constructor function, which requires 3 parameters:

1. `coords`: A numeric `data.frame` (or matrix) representing the spatial pixel locations. Row names are barcodes/pixel names, and there should be two columns for `x` and for `y`.

2. `counts`: A matrix (or `dgCmatrix`) representing Digital Gene Expression (DGE). Row names should be genes and column names should represent barcodes/pixel names. Counts should be untransformed count-level data.

3. `nUMI`: Optional, a named (by pixel barcode) list of total counts or UMIs appearing at each pixel. If not provided, `nUMI` will be assumed to be the total counts appearing on each pixel.

Here, we load coordinates and counts from the `rctd_simulation` object. Again, in practice, this step will depend on how you store your spatial transcriptomics data.

```{r SpatialRNA, fig.align='center', fig.width=5, fig.height=5, out.width='75%'}
# Create SpatialRNA object.
puck <- SpatialRNA(
  rctd_simulation$spatial_rna_coords,
  rctd_simulation$spatial_rna_counts
)

# Examine puck. (optional)
print(dim(puck@counts))      # Digital Gene Expression matrix dimensions
ggplot(puck@coords, aes(x, y)) +
  geom_point(color = "cornsilk4", size = 4) +
  ggtitle("SpatialRNA Pixels") +
  theme(plot.title = element_text(size=16, hjust = 0.5))
```
<br/>
We find that we have a spatial transciptomics dataset of 750 genes for 12 pixels, plotted above.

In this simulated dataset, the ground truth for our cell type mixtures is given by the matrix `rctd_simulation$true_proportions`. This ground truth is not known in practice, and indeed, it is what we will estimate with RCTD.

```{r trueProportions}
rctd_simulation$true_proportions
```
Inspecting the ground-truth proportions, we find that there are two distinct mixtures (of cell types `ct1`, `ct2`, and `ct3`) in our dataset: (90%, 10%, 0%) and (20%, 40%, 40%).

<details>
<summary>Let's visualize these mixtures. We define a helper function below for plotting.</summary>
```{r plotterHelper}
# Helper function to plot the cell type proportions in a SpatialRNA object.
plot_cell_mixture <- function(puck, proportions, title = NULL) {
  num_cell_types <- ncol(proportions)

  colors <- grDevices::rainbow(num_cell_types, rev = TRUE)
  names(colors) <- as.character(seq_len(num_cell_types))

  # Plot the proportions of each cell type.
  mixture_plot <- ggplot()
  for (i in seq_len(num_cell_types)) {
    # Plot the pixels where this cell type constitutes > 1% of the mixture.
    jitter <- 0.02 * i  # Add jitter to distinguish different cell types.
    is_non_zero <- proportions[, i] > 0.01
    cell_type_data <- data.frame(
      x = puck@coords$x[is_non_zero] + jitter,
      y = puck@coords$y[is_non_zero] + jitter,
      size = proportions[is_non_zero, i],
      color = as.character(i)
    )
    # Append the plot for this cell type.
    mixture_plot <- mixture_plot +
      geom_point(
        data = cell_type_data,
        aes(x = x, y = y, size = size, color = color),
        alpha = 0.75,
      )
  }

  mixture_plot +
    scale_color_manual(name = "Cell Types", values = colors) +
    scale_size(name = "Proportion", limits = seq(0, 1)) +
    ggtitle(title) +
    theme_light() +
    theme(plot.title = element_text(size=24, hjust = 0.5))
}
```
</details>

```{r trueProportionsPlot, cache = FALSE, fig.height = 5, fig.width = 7}
plot_cell_mixture(
  puck,
  rctd_simulation$true_proportions,
  title = "Ground-Truth Cell Type Mixtures"
)
```

## Running RCTD

### Creating RCTD Object

The last step before running RCTD is to create an RCTD object from our `SpatialRNA` and `Reference` objects using the `create.RCTD` function. Note that this function offers several configuration options:

* `max_cores`: Number of cores used for parallel processing. If set to 1, parallel processing is not used. The system will additionally be checked for the number of available cores. Note that we recommend setting `max_cores` to at least `4` or `8` to improve efficiency.
* `gene_cutoff`, `fc_cutoff`, `gene_cutoff_reg`, `fc_cutoff_reg`: Used for differentially expressed gene selection, with `gene_cutoff` filtering for average expression and `fc_cutoff` filtering for log-fold-change across cell types.
* `UMI_min`, `UMI_max`: Minimum and maximum read depth for pixels in the `SpatialRNA` dataset.

```{r createRCTD}
my_rctd <- create.RCTD(puck, reference, max_cores = 1)
```

### Running RCTD

We are finally ready to run RCTD using the `run.RCTD` function. The `doublet_mode` argument sets whether RCTD will be run in `"doublet"` mode (at most 1-2 cell types per pixel), `"full"` mode (no restrictions on number of cell types), or `"multi"` mode (finitely many cell types per pixel, e.g. 3 or 4).

```{r runRCTD, cache = TRUE}
my_rctd <- run.RCTD(my_rctd, doublet_mode = "doublet")
```

## RCTD results

The results of RCTD are located in the `@results` field. Of particular interest is `@results$weights`, which gives the weights of every cell type in each pixel (available in doublet mode and full mode). The results of doublet mode are stored in `@results$weights_doublet`, which gives two cell type weights for each pixel, and `@results$results_df`, whose important columns are:

* `spot_class`: A factor variable representing RCTD's classification in doublet mode: `"singlet"` (1 cell type on pixel), `"doublet_certain"` (2 cell types on pixel), `"doublet_uncertain"` (2 cell types on pixel, but only confident of 1), `"reject"` (no prediction given for pixel). 
* `first_type`: The first cell type predicted on the bead (for all spot_class conditions except "reject"). 
* `second_type column`: The second cell type predicted on the bead for doublet `spot_class` conditions (not a confident prediction for `"doublet_uncertain"`).

Note that in multi mode, `results` consists of a list of results for each pixel, which contains `all_weights` (weights from full-mode), `cell_type_list` (cell types on multi-mode), `conf_list` (which cell types are confident on multi-mode) and `sub_weights` (proportions of cell types on multi-mode).

```{r results}
results <- my_rctd@results
print(results$results_df[, c("spot_class", "first_type", "second_type")])
```

We can see that in doublet mode, RCTD succeeds in decomposing cell mixtures, although in this toy example, pixels with a (90%, 10%, 0%) mixture are classified as singlets.

Let's visualize the full-mode weights:

```{r resultsVisualization, cache = FALSE, fig.height = 5, fig.width = 7}
# Normalize the cell type proportions to sum to 1.
norm_weights <- normalize_weights(results$weights)
plot_cell_mixture(
  my_rctd@spatialRNA,
  norm_weights,
  title = "Estimated Cell Type Mixtures"
)
```

This is very close to the ground truth!

You are now ready to apply RCTD to your own spatial transcriptomics datasets.
